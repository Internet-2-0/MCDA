{"data":{"data":{"signatures":[{"discovered":[["cmp eax, 0x1994000","jne 0x401bdd","call dword [sym.imp.msvcrt.dll_void___cdecl_terminate_void_]","xor eax, eax","pop ebp","ret 4"],["ret 4","push 0x401ba0","call dword [sym.imp.KERNEL32.dll_SetUnhandledExceptionFilter]","xor eax, eax","ret","jmp dword [sym.imp.msvcrt.dll__XcptFilter]"],["push 0xc","push 0x401ef0","call fcn.00401e30","xor ecx, ecx","mov eax, dword [arg_8h]","test eax, eax"],["je 0x401cac","cmp ecx, 3","jne 0x401ca9","xor eax, eax","inc eax","pop ebp"],["add eax, 0x28","cmp edx, ebx","jb 0x401cf6","xor eax, eax","pop edi","pop esi"],["push 0x7e000033","jle 0x4030a1","xchg edx, eax","xor eax, dword [eax]","add byte [eax], ch","sub byte [ebx], dh"]],"info":{"description":"Suspicious assembly calls are calls that are using jumps, calls, or xor in quick succession of one another, these are potentially indicators of on the fly loading of imports (dynamic import loading), cryptographic intentions (such as ransomware, or encryption/decryption techniques), or possibly even sandbox evasion. These are suspicious in nature due to the file type.","title":"Suspicious Assembly"}},{"discovered":["SetUnhandledExceptionFilter","UnhandledExceptionFilter","GetTickCount","QueryPerformanceCounter"],"info":{"description":"Anti-debugging is a set of techniques used within the code of an application to detect and prevent the act of debugging. This stops attackers from dynamically running applications, trying to understand how they work and changing the behavior of certain features or checks within the application. Malicious applications use anti-debugging to prevent reverse engineers from dynamically analyzing the code and can potentially be an indication of malware.","title":"Anti-Debugging Imports"}},{"discovered":["GetModuleHandle","GetStartupInfo","ShellExecute","System","GetCurrentProcess","GetCurrentThreadId","GetTickCount","SetUnhandledExceptionFilter","UnhandledExceptionFilter"],"info":{"description":"The file statically imports commonly known malicious Windows API endpoints, or imports Windows libraries that have been used by multiple malware samples over time. It is possible that these imports are never used.","title":"Imports Known Malicious Endpoints"}},{"discovered":{"signed":false},"info":{"description":"The file is not signed by a distributor (IE Microsoft). This means that the file has no verification and may be dangerous in nature. This is not an indicator that the file is malicious, but is a warning that there is no valid signature in the binary file.","title":"No Signature Detected in Binary File"}},{"discovered":[{"raw_address":"0x00006148","virtual_address":"0x00408548","section_name":".rsrc","cave_byte_size":386}],"info":{"description":"A code cave is a series of unused bytes in a process's memory. This series of bytes can be used to inject custom instructions into the memory. This is a well known tactic for hiding malware inside of known applications but does not always mean that there is an issue.","title":"Code Cave"}},{"discovered":"malicious\n","info":{"description":"Malcore attempts to classify each file processed through an AI driven classifier.","title":"Malcore AI File Classification"}},{"discovered":{"unmarked_objects":{"is_unmarked_object":true,"total_unmarked_objects":2}},"info":{"description":"In Windows binary files there is a section called 'the Rich PE header section'. This section is responsible for (it is assumed) providing a development environment fingerprint. Anomalies inside of this header include invalid checksums, invalid xor keys, malformed 'rich data' or rich data removed, and unmarked objects in the build information. If some these occur, it is more likely that the file was tampered with, and is potentially an indicator of malicious intents.","title":"Rich PE Header Anomaly"}}],"score":"13.93/100"},"isMaintenance":false,"success":true,"messages":[{"type":"success","code":200,"message":"Scan ran"}]},"isMaintenance":false,"success":true}